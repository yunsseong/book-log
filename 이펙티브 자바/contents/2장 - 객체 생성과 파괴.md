# 2장 - 객체 생성과 파괴

## 아이템1. 생성자 대신 정적 팩터리 메서드를 고려하라
### 정적 팩터리 메서드
  - **[핵심]** 객체 생성 방식을 캡슐화하여 유연하고 효율적인 객체 생성을 가능하게 함
  - **[이점]**
    - 확장성과 유지보수성을 높임
    - 생성자보다 더 많은 제어권과 유연성을 제공
  - **[주의점]**
    - 정적 팩터리 메서드를 찾기 어려울 수 있음
      - **[해결]** 널리 알려진 정적 팩터리 메서드 이름으로 짓기
    - 정적 팩터리 메서드만 제공하면 하위 클래스를 만들 수 없음
      - **[이점]** 상속을 못하도록 의도할 때 사용 가능

## 아이템2. 생성자에 매개변수가 많다면 빌더를 고려하라
### 빌더 패턴
- **[핵심]** 선택적 매개변수들을 빌더 패턴을 통해 가독성과 안정성 있게 객체를 생성할 수 있음
- **[방법]**
  1. 생성할 클래스 안에 정적 맴버 클래스 만든다
  2. 필수 매개변수만으로 생성자를 호출한다
  3. 빌더 객체가 제공하는 세터 메서드로 선택 매개변수를 설정한다
- **[장점]**
  - 클라이언트 코드의 가독성이 좋아짐
  - 객체의 일관성을 유지할 수 있음
  - 빌더 하나로 여러 객체를 순회하면서 만들 수 있음
  - 빌더에 넘기는 매개변수에 따라 다른 객체를 만들 수 있음
- **[단점]**
  - 성능에 민감한 상황에서는 문제가 될 수 있음
  - 빌더 패턴 자체가 작성해야할 코드양이 많아 오버헤드가 있음
- **[팁]**
  - 유효성 검사 코드는 빌더의 생성자와 입력 매새변수를 검사
  - build 메서드가 호출하는 생성자에서 여러 매개변수에 걸친 불변식을 검사

## 아이템3. private 생성자나 열거 타입으로 싱글텀임을 보증하라
### 싱글턴
- **[정의]** 인스턴스를 오직 하나만 생성할 수 있는 클래스
- **[장점]**
  - 전역 상태 관리
  - 리소스 절약
- **[단점]**
  - 전역 상태로 인한 의존성
  - 멀티스레드 환경 문제
  - 유연성 저하
- **[방법]**
  - 생성자를 private으로 만든다 
    - 1. public static final 필드 사용 
    - 2. 정적 팩터리 메서드 public static 제공
    - 3. 원소가 하나인 열거 타입 선언
      - enum은 클래스 로드 시점에 한번만 초기화됨
      - 자바 언어 스펙에 의해 스레드 세이프함
      - Serialization 지원
      - Reflection API로 생성자 호출 불가

## 아이템4. 인스턴스화를 막으려거든 private 생성자를 사용하라
### private 생성자
- **[방법]** 클래스 생성자를 private으로 제한함
- **[효과]**
  - 인스턴스화를 막을 수 있음
  - 상속을 불가능하게 함
    - 모든 생성자는 상위 클래스의 생성자를 호출하기 때문

## 아이템5. 자원을 직접 명시하지 말고 의존 객체 주입을 사용하라
### 의존 객체 주입
- **[정의]** 외부에서 필요한 자원을 전달 받아 사용하도록 하는 설계 방식
- **[방법]** 생성자, 정적 팩터리, 빌더를 통해 의존 객체 전달
- **[효과]** 유연성, 재사용성, 테스트 용이성 개선

## 아이템6. 불필요한 객체 생성을 피하라
- **[사례]**
  - 문자열 new 생성
    - String s = new String("bar")
    - 매번 새로 생성된 String 객체가 힙 메모리에 저장됨
    - **[해결법]**
      - String s = "bar"
      - String Pool에서 문자열 리터럴을 가져와 참조
  - 정규표현식 Pattern
    - 인스턴스 생성 비용이 높음
    - **[해결법]** Pattern 직접 생성 및 캐싱
  - 오토박싱
    - 기본 타입과 박싱 타입을 연산
    - **[해결법]** 연산 시 기본 타입을 사용

## 아이템7. 다 쓴 객체 참조를 해제하라
- **[상황]**
  - 사용자가 직접 메모리 풀을 관리할 때
  - 객체 참조를 캐시에 넣어두고 까먹을 때
  - 리스너 콜백을 등록만 하고 해지를 안할 때
- **[방법]**
  - 참조를 다 썼을 때 null 처리
  - WeakHashMap 사용

## 아이템8. finalizer와 cleaner 사용을 피하라
- **[이유]** 수행 시점뿐 아니라 수행 여부 조차 보장하지 않음
- **[대체]** try-with-resources 블록을 사용해라

## 아이템9. try-finally보다는 try-with-resources를 사용하라
- **[이유]** try 블록과 finally 블록에서 둘 다 예외가 발생하면 먼저 발생한 예외 정보가 사라짐
- **[대체]** try-with-resources를 사용하라
  - **[장점]**
    - catch를 함께 사용하여 다수의 예외 처리 가능
    - 더 짧은 코드