# 3장 - 모든 객체의 공통 메서드

## 아이템 10. equals는 일반 규약을 지켜 재정의하라
- **[핵심]** 꼭 필요한 상황에서 equals를 재정의하고, 만약 재정의할 경우에는 아래 규약을 지켜라
- **[규약]**
  - 반사성: 객체는 자기 자신과 같아야함
  - 대칭성: 두 객체는 서로에 대한 동치 여부에 똑같이 답해야함
  - 추이성: 첫 번째 객체와 두 번째 객체가 같고, 두 번째 객체와 세 번째 객체가 같다면, 첫 번째 객체와 세 번째 객체가 같아야함
  - 일관성: 두 객체가 같다면(어느 하나 혹은 두 객체 모두가 수정되지 않는 한) 앞으로 영원히 같아야함
  - null-아님: 모든 객체가 null과 같지 않아야함
- **[체크]** 대칭적인가? 추이성이 있는가? 일관적인가?

## 아이템 11. equals를 재정의하려거든 hashCode도 재정의하라
- **[이유]**
  - hashCode 일반 규약을 어기게 됨
    - **[규약]**
      - equals 비교에 사용되는 정보가 변하지 않았다면, hashCode는 항상 같은 값을 반환해야함
      - equals(Object)가 두 객체를 같다고 판단했다면, 두 객체는 hashCode는 똑같은 값을 반환해야함
      - equals(Object)가 두 객체를 다르다고 판단했더라도, 두 객체의 hashCode는 서로 다른 값을 반환할 필요는 없음
  - HashMap, HashSet 같은 컬랙션의 원소로 사용할 때 문제가 발생
- **[방법]**
  - Objects 클래스의 정적 메서드 hash 사용
    - **[주의]**
      - 성능이 민감하지 않은 상황에 사용할 것
      - 성능을 높인다고 해시코드를 계산할 때 핵심 필드를 생략하면 안됨
      - hashCode가 반환하는 값의 생성 규칙을 API 사용자에게 자세히 공표하지 말 것

## 아이템 12. toString을 항상 재정의하라
- **[규약]**
  - 간결하면서 사람이 읽기 쉬운 형태의 정보를 반환할 것
  - 모든 하위 클래스에서 이 메서드를 재정의할 것
- **[이점]**
  - 시스템 디버깅이 쉬워짐
  - 객체의 정보를 쉽게 파악할 수 있음

## 아이템 13. clone 재정의는 주의해서 진행하라
### Cloneable
- **[용도]** 복제해도 되는 클래스임을 명시
- **[이점]** 
  - 객체를 새로 생성하고 초기화하는 것보다 복제하는 것이 더 빠를 수 있음
  - 객체 생성 비용이 비싼 경우 clone() 사용 시 성능 최적화 가능
- **[주의]** 해당 방식은 대부분의 상황에서 권장되지 않음
  - **[이유]** 기본적으로 clone()은 얕은 복사만 수행하여 원본 객체와 공유 상태를 가질 수 있음
  - **[대안]** 복사 생성자, 팩토리 메서드를 사용하여 복제하는 것을 권고

## 아이템 14. Comparable을 구현할지 고려하라
### Comparable
- **[정의]** 기본 정렬 순서(natural order)를 정의하는 인터페이스
- **[사용법]**
  - 클래스에서 Comparable 인터페이스 구현, compareTo 메서드 오버라이드
    - **[반환]**
      - 음수: 현재 객체가 더 작음
      - 0: 두 객체가 같음
      - 양수: 현재 객체가 더 큼
  - 주로 한 가지 정렬 기준이 있을 때 사용됨
- **[권고]** compareTo 메서드로 수행한 동치성 테스트의 결과가 equals와 같아야함
  - **[이유]** 객체 동치성을 비교할 때 상황에 따라 equals가 아닌 compareTo를 사용하는 경우가 있음

### Comparator
- **[정의]** 사용자 정의 순서(custom order)를 정의하는 인터페이스
- **[사용법]**
  - Comparator 인터페이스 구현, 람다 표현식 혹은 메서드 참조를 사용하여 동적으로 정렬 기준 정의
    - **[반환]**
      - 음수: 첫 번째 객체가 더 작음
      - 0: 두 객체가 같음
      - 양수: 첫 번째 객체가 더 큼
  - 주로 여러 정렬 기준이 있을 때 혹은 Comparable을 구현할 수 없을 때 사용
- **[주의]** 값의 차를 기준으로 비교하면 안됨
  - **[이유]** 어버플로우를 일으키거나 IEEE 754 부동소수점 계산 방식에 따른 오류를 낼 수 있음