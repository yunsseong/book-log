# Chapter04 - SOLID

## SOLID 원칙
- **[목표]** 소프트웨어의 유지보수성과 확장성을 높이는 것
  - **[방법]** 유지보수성은 어떻게 판단하는가?
    - 영향 범위
    - 의존성
    - 확장성
- **[핵심]** 높은 응집도, 낮은 결합도

### 단일 책임 원칙 (SRP: Single Responsibility Principle)
- **[정의]** 클래스에는 단 하나의 책임만 있어야함
- **[목적]** 변경으로 인한 영향 범위를 최소화하는 것
- **[목표]**
  - 클래스가 변경됐을 때 영향 받는 액터가 하나여야함
  - 클래스를 변경할 이유는 유일한 액터의 요구사항이 변경될 때로 제한해야함
- **[용어]**
  - **[액터]** 메세지를 전달하는 주체
  - **[책임]** 액터에 대한 책임
- **[이점]**
    - 할당된 책임이 하나면 코드를 이해하기 쉬워짐
    - 코드 수정이 필요하면 특정 클래스나 모듈만 수정하면 되므로 수정이 용이함
    - 유지보수가 필요할 때 다른 책임과의 충돌을 걱정할 필요가 없음
    - 변경으로 인한 영향을 최소화할 수 있음
- **[사례]**
  - 어떤 모듈이나 클래스가 담당하는 액터가 혼자임 (SRP 준수)
  - 어떤 모듈이나 클래스가 담당하는 액터가 여럿임 (SRP 위반)

### 개방 폐쇄 원칙 (OCP: Open-Close Principle)
- **[정의]** 확장에는 열려 있고 변경에는 닫혀 있어야함
- **[목적]** 기존 코드를 수정하지 않으면서 확장 가능한 시스템 구현
  - **[이유]** 시스템을 운영하면서 코드를 변경하는 것은 매우 위험한 일임
- **[방법]** 코드를 추상화된 역할에 의존하게 만듦
- **[예시]** 주문 상품 계산

### 리스코프 치환 원칙 (LSP: Liskov Substitution Principle)
- **[정의]** 기본 클래스의 계약을 파생 클래스가 제대로 치환할 수 있는지 확인
- **[해석]** 부모 클래스 자리에 자식 클래스가 와도 제대로 동작해야함
- **[주의]**
  - 파생 클래스가 기본 클래스를 대체하려면 기본 클래스에 할당된 의도와 계약을 확인해야함
  - 코드만 보고 작성자의 의도를 알 수 없음
  - **[의도 표현 방법]** 테스트 코드를 작성해 의도 표현하기
- - **[예시]** 직사각형 클래스를 상속한 정사각형 클래스

### 인터페이스 분리 원칙 (ISP: Interface Segregation Principle)
- **[정의]** 클라이언트가 자신이 사용하지 않는 인터페이스에 의존하지 않아야함
- **[해석]** 어떤 클래스가 자신에게 필요하지 않은 인터페이스의 메서드를 구현하거나 의존하지 않아야함
- **[목적]** 역할과 책임을 분리하고 역할을 세세하게 나눠서 기능적 응집도를 추구하기 위함
- **[이점]**
  - 인터페이스의 크기를 작게 유지할 수 있음
  - 클래스가 필요한 기능에만 집중할 수 있음
- **[반대 사례]** 인터페이스를 통합한다
  - **[해석]** 유사한 코드라서 한곳에 모음 -> 논리적 응집도 -> 가장 우선순위가 낮음
  - **[단점]** 인터페이스의 역할이 두루뭉실해짐
- - **[예시]** AnnotationBeanConfigurerAspect

#### 응집도
- **[정의]** 모듈 또는 클래스 내 컴포넌트들이 얼마나 밀접하게 연관되어 있는지를 나타냄
- **[분류]**
  - 기능적 응집도: 모듈 내 컴포넌트들이 같은 기능을 수행하도록 설계된 경우
  - 순차적 응집도: 모듈 내의 컴포넌트들이 특정한 작업을 수행하기 위해 순차적으로 연결된 경우
  - 통신적 응집도: 모듈 내의 컴포넌트들이 같은 데이터나 정보를 공유하고 상호작용할 때 이에 따라 모듈을 구성하는 경우
  - 절차적 응집도: 모듈 내의 요소들이 단계별 절차를 따라 동작하도록 설계된 경우
  - 논리적 응집도: 모듈 내의 요소들이 같은 목적을 달성하기 위해 논리적으로 연관된 경우

### 의존성 역전 원칙 (DIP: Dependency Inversion Principle)
- **[정의]**
  - 상위 모듈은 하위 모듈에 의존해서는 안 된다. 상위 모듈과 하위 모듈 모두 추상화에 의존해야함
  - 추상화는 세부 사항에 의존해서는 안된다. 세부 사항이 추상화에 의존해야함
- **[정리]**
  - 고수준 모듈은 추상화에 의존해야함
  - 고수준 모듈이 저수준 모듈에 의존하면 안됨
  - 저수준 모듈은 추상화를 구현해야함

#### 의존 (=결합)
- **[정의]** 다른 객체나 함수를 사용하는 상태
- **[낮추는 방법]** 의존성 주입
- **[특징]** 의존성 전이
  - 한 컴포넌트가 변경되거나 영향을 받으면 다른 컴포넌트에도 영향이 갈 수 있음
  - 의존성은 화살표 역방향으로 전이됨

#### 의존성 주입 (Dependency Injection)
- **[정의]** 필요한 의존성을 외부에서 넣어줌
- **[방법]**
  - 매개변수 주입
  - 생성자 주입
  - 수정자 주입
- **[이점]** 불필요한 강한 의존을 피하게 도움을 줌
- **[주의]** 프레임워크 도움 없이도 사용할 수 있는 기법
- **[예시]** 레스토랑 + 쉐프

#### new 사용
- **[결과]** 강한 결합  
  - **[이유]** 파생 클래스를 인스턴스화해서 할당하면 추상 타입과 관계없이 고정된 객체를 사용하겠다는 의미
  - **[해결방법]** 구현 객체가 인스턴화되는 시점을 최대한 뒤로 미뤄라

### 의존성 역전 (Dependency Inversion)
- **[정의]** 의존 방향을 바꾸는 기법
- **[방법]** 세부 사항에 의존하지 않고 정책에 의존하도록 코드를 작성하라
- **[결과]**
  - 코드의 경계를 만듦
  - 모듈의 범위를 정하고 상하 관계를 표현하는데 사용할 수 있는 수단임
- **[이점]**
  - 상위 모듈을 그대로 재사용하고 하위 모듈을 교체해서 새로운 기능을 제공하도록 변경
- **[예시]** 레스토랑 + 쉐프

### 의존성과 스프링
- **[질문]**
  - 스프링은 의존성 주입을 지원하는 프레임워크 (O)
  - 스프링은 의존성 역전 원칙을 지원하는 프레임워크 (X)
    - **[이유]** 의존성 역전 원칙은 설계의 영역이여서 개발자가 능동적으로 신경 써야함

### 의존성 강조 이유
- **[유지보수성]**
  - 영향 범위 -> 응집도를 높이고 적절히 모듈화하여 단일 책임 원칙을 준수하는 코드 작성
  - 의존성 -> 의존성 주입과 의존성 역전 원칙 적용 약한 의존 관계
  - 확장성 -> 의존성 역저 원칙 사용해 개방 폐쇄 원칙을 준수하는 코드 작성

### 핵심
- **[목표]** 변경으로 인한 영향 범위를 축소
  - **[방법]** 의존성을 잘 관리하는 것

### SOLID와 객체지향
- **[SOLID 핵심]**
  - 변경에 유연하고 확장할 수 있는 코드를 만드는데 초점
  - 설계 원칙, 응집도를 높이고 의존성을 낮추는 방법에 집중
- **[객체지향 핵심]** 역할, 책임, 협력
- **[주의]** SOLID를 추구한다고해서 객체지향으로 이어지는 것이 아님
- **[연습]** SOLID가 해결하려 했던 문제와 추구했던 목표가 무엇인지 고민할 것

### 디자인 패턴
- **[정의]** 범용적이고 흔히 볼 수 있는 문제 상황과 이를 해결하는 모범 사례
- **[분류]**
  - 생성 패턴: 객체 생성을 유연하고 효율적으로 처리하는 방법
  - 구조 패턴: 객체를 조합해서 더 큰 구조를 형성하는 방법
  - 행동 패턴: 객체 간의 행위와 역할을 조정하는 방법
- **[목표]** 객체 간의 상호작용을 개선하고 유연성을 높임
- **[연습]** 무작정 디자인 패턴을 고민하지말고 의존성을 고민하면 저절로 디자인 패턴이 적용됨

### 패턴
- **[정의]** 문제 인식, 해결 과정, 해결 방법을 정리한 것
- **[주의]** 패턴은 도구일 뿐 실제로 중요한 것은 패턴에 담긴 문제 인식, 해결 과정, 해결 방법임